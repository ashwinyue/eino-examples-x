# 狼人杀游戏系统设计与 eino adk Agent 模式分析

## 1. 狼人杀游戏核心需求分析

### 1.1 游戏流程
- **夜晚行动**：狼人选择杀人目标
- **天亮公布**：公布夜晚死亡信息
- **发言环节**：每个玩家依次发言
- **投票处决**：玩家投票处决嫌疑人
- **胜负判断**：重复上述流程，直到村民或狼人获胜

### 1.2 角色设计
- **村民**：目标是找出并处决所有狼人
- **狼人**：目标是杀死所有村民，隐藏自己的身份

### 1.3 Agent 能力需求
- **角色身份记忆**：长期记忆管理，记住自己的角色和游戏中的关键信息
- **发言策略生成**：基于当前局势推理，生成合适的发言
- **身份伪装或揭露**：狼人需隐藏身份，村民可推理揭露

### 1.4 游戏流程控制
- 需要一个主持人协调阶段流转，确保顺序正确
- 管理游戏状态，记录死亡玩家、投票结果等

## 2. eino adk Agent 模式分析

### 2.1 eino adk 核心 Agent 类型

#### 2.1.1 ChatModelAgent
- **定义**：基于聊天模型的 Agent，用于生成自然语言响应
- **核心组件**：
  - 模型配置：指定使用的大语言模型
  - 指令配置：定义 Agent 的角色和职责
  - 工具配置：可选，允许 Agent 调用外部工具
- **适用场景**：需要生成自然语言响应的场景，如对话、推理、决策

#### 2.1.2 Supervisor
- **定义**：协调多个 sub-agent 的 Agent，用于管理工作流
- **核心组件**：
  - 子 Agent 列表：管理多个 sub-agent
  - 工作流配置：定义子 Agent 之间的协作流程
  - 决策逻辑：决定何时调用哪个 sub-agent
- **适用场景**：需要协调多个 Agent 完成复杂任务的场景

### 2.2 eino adk Agent 协作模式

#### 2.2.1 层级协作模式
- **结构**：Supervisor 作为顶层协调者，管理多个 sub-agent
- **流程**：Supervisor 接收任务 → 分解任务 → 分配给合适的 sub-agent → 收集结果 → 返回最终结果
- **优势**：流程可控，便于管理复杂任务

#### 2.2.2 平行协作模式
- **结构**：多个 Agent 并行工作，各自完成独立的任务
- **流程**：每个 Agent 独立接收任务 → 完成任务 → 返回结果
- **优势**：并行处理，提高效率

#### 2.2.3 循环协作模式
- **结构**：Agent 之间形成循环，持续交互
- **流程**：Agent A 完成任务 → 传递给 Agent B → Agent B 完成任务 → 传递给 Agent A → 循环直到任务完成
- **优势**：适合需要持续交互的场景

## 3. 狼人杀游戏系统设计

### 3.1 系统架构

```
┌─────────────────────────────────────────────────────────────────┐
│                         游戏系统                                │
├─────────────────┬─────────────────┬─────────────────────────────┤
│  主持人 Agent   │   玩家 Agent    │        记忆管理系统          │
│  (Supervisor)   │ (ChatModelAgent)│        (Milvus)              │
└─────────────────┴─────────────────┴─────────────────────────────┘
        │                │                         │
        └────────────────┼─────────────────────────┘
                         ▼
               ┌─────────────────┐
               │   游戏状态管理   │
               └─────────────────┘
```

### 3.2 核心组件设计

#### 3.2.1 主持人 Agent
- **Agent 类型**：Supervisor
- **核心职责**：
  - 游戏流程控制：协调夜晚行动、天亮公布、发言环节、投票处决等阶段
  - 游戏状态管理：维护游戏状态，记录死亡玩家、投票结果等
  - 胜负判断：判断村民或狼人是否获胜
  - 玩家协调：协调玩家 Agent 的行动顺序
- **设计思路**：
  - 使用 Supervisor 模式，管理所有玩家 Agent
  - 定义清晰的游戏流程，确保各个阶段顺序正确
  - 维护全局游戏状态，确保所有玩家 Agent 共享一致的游戏信息
- **Prompt 模板示例**：
  ```
  你是狼人杀游戏的主持人，负责控制游戏流程，协调各个阶段的转换。
  
  你的职责包括：
  1. 游戏初始化：分配角色，初始化游戏状态
  2. 阶段控制：按照夜晚行动 → 天亮公布 → 发言环节 → 投票处决 → 胜负判断的顺序控制游戏流程
  3. 状态管理：记录死亡玩家、投票结果等游戏状态
  4. 胜负判断：根据游戏规则判断村民或狼人是否获胜
  5. 玩家协调：协调玩家 Agent 的行动顺序，确保游戏顺利进行
  
  你需要严格按照游戏规则执行，确保游戏流程的正确性和公平性。
  ```

#### 3.2.2 玩家 Agent
- **Agent 类型**：ChatModelAgent
- **核心职责**：
  - 角色身份记忆：记住自己的角色和游戏中的关键信息
  - 发言策略生成：基于当前局势和历史记忆生成合适的发言
  - 身份伪装或揭露：狼人隐藏身份，村民推理揭露
  - 投票决策：基于当前局势和历史记忆投票处决嫌疑人
- **设计思路**：
  - 每个玩家是一个独立的 ChatModelAgent
  - 为不同角色设计不同的 Prompt 模板，注入角色性格
  - 集成记忆管理系统，实现跨轮次的记忆存储和检索
  - 实现 RAG 增强，让 Agent 能够基于历史记忆生成更智能的决策
- **Prompt 模板示例**：
  - **村民 Prompt**：
    ```
    你是狼人杀游戏中的村民，你的目标是找出并处决所有狼人。
    
    你的角色性格：谨慎型村民，说话小心谨慎，善于观察和推理，不会轻易怀疑他人，需要有足够的证据才会发言。
    
    你的职责包括：
    1. 记住自己的角色身份，不要暴露
    2. 在发言环节，基于当前局势和历史记忆生成合适的发言
    3. 在投票环节，基于当前局势和历史记忆投票处决你认为最有可能是狼人的玩家
    4. 观察其他玩家的发言和行为，推理他们的身份
    
    你需要根据游戏进程，不断调整自己的策略，最终帮助村民阵营获胜。
    ```
  - **狼人 Prompt**：
    ```
    你是狼人杀游戏中的狼人，你的目标是杀死所有村民，隐藏自己的身份。
    
    你的角色性格：激进型狼人，说话激进，善于引导话题，会主动攻击其他玩家，转移注意力。
    
    你的职责包括：
    1. 记住自己的角色身份，隐藏自己的狼人身份
    2. 在夜晚行动阶段，与其他狼人协商，选择杀人目标
    3. 在发言环节，基于当前局势和历史记忆生成合适的发言，隐藏自己的身份，误导村民
    4. 在投票环节，基于当前局势和历史记忆投票处决你认为最有可能暴露的狼人或最危险的村民
    5. 观察其他玩家的发言和行为，调整自己的伪装策略
    
    你需要根据游戏进程，不断调整自己的策略，最终帮助狼人阵营获胜。
    ```

#### 3.2.3 记忆管理系统
- **核心组件**：Milvus 向量数据库
- **核心职责**：
  - 存储游戏中的关键信息：发言内容、发言者、时间、游戏阶段等
  - 实现跨轮次的记忆检索：根据当前上下文检索相关的历史记忆
  - 支持情景记忆+语义记忆机制：存储具体的游戏事件和抽象的语义信息
- **设计思路**：
  - 使用 Milvus 向量数据库存储游戏记忆
  - 将游戏记忆转换为向量表示，便于相似度检索
  - 实现记忆的实时更新和检索，支持 Agent 在决策时获取相关记忆
- **数据结构设计**：
  | 字段名 | 数据类型 | 描述 | 用途 |
  |--------|----------|------|------|
  | id | INT64 | 唯一标识符 | 主键，自增 |
  | content | VARCHAR(65535) | 记忆内容 | 存储发言、行动等具体内容 |
  | speaker | VARCHAR(255) | 发言者或行动者 | 标识记忆的来源 |
  | phase | VARCHAR(255) | 游戏阶段 | 标识记忆产生的游戏阶段 |
  | timestamp | INT64 | 时间戳 | 记录记忆产生的时间 |
  | vector | FLOAT_VECTOR(1536) | 向量表示 | 用于相似度检索 |
- **向量生成方法**：
  - 使用 OpenAI Embedding 模型（如 text-embedding-3-small）将文本转换为向量
  - 向量维度：1536
  - 生成方式：将记忆内容（如发言内容）输入到 Embedding 模型，获取向量表示
- **索引设计**：
  - 索引类型：IVF_FLAT
  - 索引参数：nlist=128
  - 适用场景：适合中小规模数据集，检索精度高

#### 3.2.4 RAG 增强设计
- **核心职责**：
  - 检索增强：在 Agent 决策前，检索相关的历史记忆
  - 上下文融合：将检索到的记忆融合到 Agent 的决策上下文中
  - 生成优化：基于融合后的上下文生成更智能的决策和发言
- **设计思路**：
  - 在 Agent 决策前，使用当前上下文作为查询向量，检索相关的历史记忆
  - 将检索到的记忆与当前上下文融合，生成完整的决策上下文
  - 将融合后的上下文输入到大语言模型，生成决策或发言
- **检索策略**：
  - 相似度检索：使用 L2 距离计算向量相似度
  - 过滤条件：可根据游戏阶段、发言者等条件过滤记忆
  - 检索数量：每次检索 5-10 条最相关的记忆
- **上下文融合方法**：
  ```
  当前上下文：
  {当前游戏阶段}
  {当前游戏状态}
  {当前需要决策的内容}
  
  相关历史记忆：
  1. {记忆1}
  2. {记忆2}
  ...
  
  请基于当前上下文和相关历史记忆，生成合适的{发言/投票决策}。
  ```

### 3.3 游戏流程实现

#### 3.3.1 初始化阶段
1. 主持人 Agent 分配角色：3村民 + 2狼人
2. 主持人 Agent 初始化游戏状态
3. 主持人 Agent 创建 Milvus 集合，用于存储游戏记忆
4. 主持人 Agent 向每个玩家 Agent 发送角色信息
5. 主持人 Agent 记录初始化信息到 Milvus 记忆系统

#### 3.3.2 夜晚阶段
1. 主持人 Agent 通知所有玩家进入夜晚阶段
2. 主持人 Agent 只允许狼人玩家 Agent 交流，选择杀人目标
3. 狼人玩家 Agent 协商杀人目标，通过主持人 Agent 传递信息
4. 主持人 Agent 记录夜晚行动到 Milvus 记忆系统
5. 主持人 Agent 确定死亡玩家

#### 3.3.3 天亮阶段
1. 主持人 Agent 通知所有玩家进入天亮阶段
2. 主持人 Agent 公布死亡信息
3. 主持人 Agent 记录死亡信息到 Milvus 记忆系统
4. 主持人 Agent 检查游戏是否结束
5. 如果游戏结束，进入结果阶段；否则，进入发言阶段

#### 3.3.4 发言阶段
1. 主持人 Agent 通知所有玩家进入发言阶段
2. 主持人 Agent 确定发言顺序
3. 每个玩家 Agent 依次发言：
   - 玩家 Agent 从 Milvus 记忆系统检索相关历史记忆
   - 玩家 Agent 基于当前局势和历史记忆生成发言
   - 玩家 Agent 发送发言内容给主持人 Agent
   - 主持人 Agent 记录发言内容到 Milvus 记忆系统
   - 主持人 Agent 将发言内容转发给所有玩家 Agent

#### 3.3.5 投票阶段
1. 主持人 Agent 通知所有玩家进入投票阶段
2. 每个玩家 Agent 投票处决嫌疑人：
   - 玩家 Agent 从 Milvus 记忆系统检索相关历史记忆
   - 玩家 Agent 基于当前局势和历史记忆生成投票决策
   - 玩家 Agent 发送投票结果给主持人 Agent
   - 主持人 Agent 记录投票结果到 Milvus 记忆系统
3. 主持人 Agent 统计投票结果，确定被处决的玩家
4. 主持人 Agent 公布处决结果
5. 主持人 Agent 记录处决结果到 Milvus 记忆系统
6. 主持人 Agent 检查游戏是否结束
7. 如果游戏结束，进入结果阶段；否则，进入下一轮夜晚阶段

#### 3.3.6 结果阶段
1. 主持人 Agent 公布游戏结果
2. 主持人 Agent 记录游戏结果到 Milvus 记忆系统
3. 主持人 Agent 结束游戏

### 3.4 技术选型

| 技术组件 | 技术选型 | 版本 | 用途 | 选型理由 |
|----------|----------|------|------|----------|
| 开发语言 | Go | 1.22 | 实现游戏核心逻辑 | 高性能，适合并发场景，与 eino adk 兼容 |
| Agent 框架 | eino adk | 0.7.3 | 实现多 Agent 协作 | 支持 Supervisor + ChatModelAgent 模式，适合游戏流程控制 |
| 向量数据库 | Milvus | 2.4.0 | 实现记忆管理和 RAG 增强 | 高性能向量检索，支持相似度检索，适合游戏记忆存储和检索 |
| 大语言模型 | OpenAI GPT-4o | - | 生成 Agent 发言和决策 | 强大的自然语言生成能力，支持复杂推理 |
| Embedding 模型 | OpenAI text-embedding-3-small | - | 生成记忆向量 | 适合中文文本，向量维度适中，检索效果好 |

### 3.5 性能优化考虑

#### 3.5.1 Milvus 索引优化
- **索引类型选择**：使用 IVF_FLAT 索引，适合中小规模数据集，检索精度高
- **索引参数调整**：nlist 参数设置为 128，平衡检索速度和精度
- **向量维度优化**：使用 1536 维度的向量，平衡检索效果和存储成本

#### 3.5.2 检索策略优化
- **检索数量控制**：每次检索 5-10 条最相关的记忆，平衡检索效果和响应时间
- **过滤条件优化**：使用游戏阶段、发言者等条件过滤记忆，减少检索范围
- **缓存机制**：对频繁检索的记忆进行缓存，减少 Milvus 访问次数

#### 3.5.3 并发优化
- **Agent 并行处理**：使用平行协作模式，让多个玩家 Agent 并行处理发言和投票
- **Milvus 批量操作**：使用批量插入和批量检索，减少 Milvus 访问次数
- **异步处理**：使用异步方式处理非关键操作，提高系统响应速度

### 3.6 可扩展性设计

#### 3.6.1 角色扩展
- **设计思路**：使用模块化设计，将角色逻辑与游戏流程分离
- **实现方式**：
  - 定义角色接口，包含角色名称、目标、能力等属性
  - 每个角色实现角色接口，定义自己的行为逻辑
  - 主持人 Agent 根据配置动态加载角色
- **支持的扩展角色**：预言家、女巫、猎人、守卫等

#### 3.6.2 游戏规则扩展
- **设计思路**：使用规则引擎，将游戏规则与游戏流程分离
- **实现方式**：
  - 定义规则接口，包含规则名称、触发条件、执行逻辑等属性
  - 每个规则实现规则接口，定义自己的执行逻辑
  - 主持人 Agent 根据配置动态加载规则
- **支持的扩展规则**：遗言规则、警长竞选规则、平票规则等

#### 3.6.3 玩家数量扩展
- **设计思路**：使用动态配置，支持不同数量的玩家
- **实现方式**：
  - 主持人 Agent 根据配置动态生成玩家列表
  - 角色分配逻辑支持动态调整狼人和村民的比例
  - 游戏流程支持动态调整发言顺序和投票规则
- **支持的玩家数量**：5-12 人

## 4. eino adk Agent 模式应用分析

### 4.1 Supervisor 模式在主持人 Agent 中的应用

#### 4.1.1 核心优势
- **流程可控**：主持人 Agent 作为 Supervisor，可以严格控制游戏流程，确保各个阶段顺序正确
- **状态管理**：主持人 Agent 可以维护全局游戏状态，确保所有玩家 Agent 共享一致的游戏信息
- **协调能力**：主持人 Agent 可以协调多个玩家 Agent 的行动，确保游戏顺利进行
- **扩展性强**：可以方便地添加新的游戏阶段或角色

#### 4.1.2 实现方式
- 使用 `adk.NewChatModelAgent` 创建主持人 Agent 实例
- 使用 `supervisor.New` 创建 Supervisor，管理所有玩家 Agent
- 定义清晰的游戏流程，在 Supervisor 的指令中指定
- 维护全局游戏状态，确保所有玩家 Agent 共享一致的游戏信息

### 4.2 ChatModelAgent 模式在玩家 Agent 中的应用

#### 4.2.1 核心优势
- **自然语言生成**：玩家 Agent 可以生成自然、流畅的发言
- **推理能力**：玩家 Agent 可以基于当前局势和历史记忆进行推理
- **角色个性化**：可以为不同角色设计不同的 Prompt 模板，注入角色性格
- **独立性强**：每个玩家 Agent 是独立的，可以并行处理

#### 4.2.2 实现方式
- 使用 `adk.NewChatModelAgent` 创建玩家 Agent 实例
- 为不同角色设计不同的 Prompt 模板，注入角色身份和性格
- 集成记忆管理系统，实现跨轮次的记忆存储和检索
- 实现 RAG 增强，让 Agent 能够基于历史记忆生成更智能的决策

### 4.3 记忆管理与 RAG 增强

#### 4.3.1 核心优势
- **跨轮次记忆**：玩家 Agent 可以记住多轮游戏中的关键信息
- **语义检索**：可以基于语义相似度检索相关的历史记忆
- **决策增强**：结合历史记忆，玩家 Agent 可以生成更智能的决策和发言
- **可扩展性强**：可以方便地扩展记忆的类型和检索方式

#### 4.3.2 实现方式
- 使用 Milvus 向量数据库存储游戏记忆
- 将游戏记忆转换为向量表示，便于相似度检索
- 在玩家 Agent 决策前，检索相关的历史记忆
- 将检索到的记忆融合到 Agent 的决策上下文中
- 基于融合后的上下文生成更智能的决策和发言

## 5. 系统优势与创新点

### 5.1 系统优势
- **多 Agent 协作**：使用 eino adk 的 Supervisor + ChatModelAgent 模式，实现了高效的多 Agent 协作
- **智能决策**：结合大语言模型和向量数据库，实现了基于历史记忆的智能决策
- **流程可控**：主持人 Agent 严格控制游戏流程，确保游戏顺利进行
- **角色个性化**：为不同角色设计不同的 Prompt 模板，注入角色性格，增强游戏的趣味性
- **可扩展性强**：可以方便地添加新的游戏阶段或角色

### 5.2 创新点
- **基于向量数据库的记忆管理**：使用 Milvus 向量数据库实现了高效的游戏记忆存储和检索
- **RAG 增强的 Agent 决策**：结合大语言模型和向量数据库，实现了基于历史记忆的智能决策
- **多 Agent 协作的游戏流程**：使用 Supervisor 模式协调多个玩家 Agent，实现了复杂的游戏流程
- **角色个性化的 Agent 设计**：为不同角色设计不同的 Prompt 模板，注入角色性格，增强了游戏的趣味性和挑战性

## 6. 总结

本设计方案基于 eino adk 的 Agent 模式，实现了一个完整的狼人杀游戏系统。系统采用了 Supervisor 模式作为主持人 Agent，协调游戏流程；采用了 ChatModelAgent 模式作为玩家 Agent，实现了智能的发言和决策；使用 Milvus 向量数据库实现了高效的记忆管理和 RAG 增强。

该设计方案具有流程可控、智能决策、角色个性化、可扩展性强等优势，能够实现一个有趣、具有挑战性的狼人杀游戏。同时，该设计方案也展示了 eino adk 在多 Agent 协作场景中的强大能力，为类似的游戏或应用提供了参考。

通过该设计方案，我们可以看到，eino adk 的 Agent 模式非常适合构建复杂的多 Agent 协作系统，尤其是需要流程控制、智能决策和记忆管理的场景。

## 7. 后续扩展方向

### 7.1 角色扩展
- 添加更多角色：预言家、女巫、猎人、守卫等
- 为每个角色设计独特的能力和行为逻辑
- 支持角色组合配置，允许用户自定义游戏角色

### 7.2 游戏规则扩展
- 添加遗言规则：被杀死或处决的玩家可以留下遗言
- 添加警长竞选规则：玩家可以竞选警长，获得额外投票权
- 添加平票规则：处理投票平票的情况

### 7.3 可视化界面
- 实现 Web 可视化界面，展示游戏流程和 Agent 决策过程
- 支持实时查看游戏状态、玩家发言、投票结果等
- 支持游戏回放功能，便于分析游戏过程

### 7.4 智能优化
- 优化 Agent 决策逻辑，提高游戏的趣味性和挑战性
- 实现 Agent 自我学习机制，让 Agent 从游戏中学习，不断改进策略
- 支持不同难度级别，适应不同玩家需求

### 7.5 多语言支持
- 支持中文、英文等多种语言
- 优化不同语言下的 Prompt 模板和 Embedding 模型

通过这些扩展方向，可以进一步增强游戏的趣味性、挑战性和可扩展性，吸引更多玩家参与游戏，同时也可以为 AI 研究提供更多的实验数据和场景。